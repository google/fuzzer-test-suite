diff -ruN gnutls-vanilla/lib/pubkey.c gnutls_3.5.0_sign/lib/pubkey.c
--- gnutls-vanilla/lib/pubkey.c	2016-07-06 14:02:33.298994233 -0400
+++ gnutls_3.5.0_sign/lib/pubkey.c	2016-07-06 15:49:54.201136838 -0400
@@ -1,7 +1,7 @@
 /*
  * GnuTLS public key support
  * Copyright (C) 2010-2012 Free Software Foundation, Inc.
- * 
+ *
  * Author: Nikos Mavrogiannopoulos
  *
  * The GnuTLS is free software; you can redistribute it and/or
@@ -504,7 +504,7 @@
  *
  * This function returns the OpenPGP key ID of the corresponding key.
  * The key is a unique ID that depends on the public
- * key parameters. 
+ * key parameters.
  *
  * If the flag %GNUTLS_PUBKEY_GET_OPENPGP_FINGERPRINT is specified
  * this function returns the fingerprint of the master key.
@@ -581,7 +581,7 @@
  * @flags: Should be zero
  *
  * This function will import the given public key to the abstract
- * #gnutls_pubkey_t type. 
+ * #gnutls_pubkey_t type.
  *
  * Returns: On success, %GNUTLS_E_SUCCESS (0) is returned, otherwise a
  *   negative error value.
@@ -1053,16 +1053,16 @@
 
 /**
  * gnutls_pubkey_import:
- * @key: The public key. 
- * @data: The DER or PEM encoded certificate. 
- * @format: One of DER or PEM 
- * 
+ * @key: The public key.
+ * @data: The DER or PEM encoded certificate.
+ * @format: One of DER or PEM
+ *
  * This function will import the provided public key in
  * a SubjectPublicKeyInfo X.509 structure to a native
- * %gnutls_pubkey_t type. The output will be stored 
- * in @key. If the public key is PEM encoded it should have a header 
- * of "PUBLIC KEY". 
- * 
+ * %gnutls_pubkey_t type. The output will be stored
+ * in @key. If the public key is PEM encoded it should have a header
+ * of "PUBLIC KEY".
+ *
  * Returns: On success, %GNUTLS_E_SUCCESS (0) is returned, otherwise a
  * negative error value.
  *
@@ -1595,7 +1595,7 @@
  * This function will verify the given signed data, using the
  * parameters from the certificate.
  *
- * Returns: In case of a verification failure %GNUTLS_E_PK_SIG_VERIFY_FAILED 
+ * Returns: In case of a verification failure %GNUTLS_E_PK_SIG_VERIFY_FAILED
  * is returned, and zero or positive code on success. For known to be insecure
  * signatures this function will return %GNUTLS_E_INSUFFICIENT_SECURITY unless
  * the flag %GNUTLS_VERIFY_ALLOW_BROKEN is specified.
@@ -1655,7 +1655,7 @@
  * this function accepts a signature algorithm instead of a digest algorithm.
  * You can use gnutls_pk_to_sign() to get the appropriate value.
  *
- * Returns: In case of a verification failure %GNUTLS_E_PK_SIG_VERIFY_FAILED 
+ * Returns: In case of a verification failure %GNUTLS_E_PK_SIG_VERIFY_FAILED
  * is returned, and zero or positive code on success.
  *
  * Since: 3.0
@@ -1673,7 +1673,9 @@
 		gnutls_assert();
 		return GNUTLS_E_INVALID_REQUEST;
 	}
-
+#ifdef FUZZER_DISABLE_SIGNCHECK
+    return 1;
+#endif
 	if (flags & OLD_PUBKEY_VERIFY_FLAG_TLS1_RSA || flags & GNUTLS_VERIFY_USE_TLS1_RSA) {
 		return _gnutls_pk_verify(GNUTLS_PK_RSA, hash, signature,
 					 &key->params);
@@ -1771,7 +1773,7 @@
 	return 0;
 }
 
-/* Returns the public key. 
+/* Returns the public key.
  */
 int
 _gnutls_pubkey_get_mpis(gnutls_pubkey_t key, gnutls_pk_params_st * params)
@@ -1893,7 +1895,7 @@
 	return _gnutls_pk_verify(pk, &digest, signature, params);
 }
 
-/* Verifies the signature data, and returns GNUTLS_E_PK_SIG_VERIFY_FAILED if 
+/* Verifies the signature data, and returns GNUTLS_E_PK_SIG_VERIFY_FAILED if
  * not verified, or 1 otherwise.
  */
 int
@@ -1934,7 +1936,7 @@
 	}
 }
 
-/* Verifies the signature data, and returns GNUTLS_E_PK_SIG_VERIFY_FAILED if 
+/* Verifies the signature data, and returns GNUTLS_E_PK_SIG_VERIFY_FAILED if
  * not verified, or 1 otherwise.
  */
 int
@@ -1950,8 +1952,10 @@
 
 		if (_pkcs1_rsa_verify_sig
 		    (me, data, NULL, signature, issuer_params) != 0) {
-			gnutls_assert();
-			return GNUTLS_E_PK_SIG_VERIFY_FAILED;
+#ifndef FUZZER_DISABLE_SIGNCHECK
+            gnutls_assert();
+            return GNUTLS_E_PK_SIG_VERIFY_FAILED;
+#endif
 		}
 
 		return 1;
@@ -1961,8 +1965,10 @@
 	case GNUTLS_PK_DSA:
 		if (dsa_verify_data(pk, me, data, signature, issuer_params)
 		    != 0) {
-			gnutls_assert();
-			return GNUTLS_E_PK_SIG_VERIFY_FAILED;
+#ifndef FUZZER_DISABLE_SIGNCHECK
+            gnutls_assert();
+            return GNUTLS_E_PK_SIG_VERIFY_FAILED;
+#endif
 		}
 
 		return 1;
@@ -2047,7 +2053,7 @@
  * @flags: should be zero
  *
  * This function will import the given public key to the abstract
- * #gnutls_pubkey_t type. 
+ * #gnutls_pubkey_t type.
  *
  * Returns: On success, %GNUTLS_E_SUCCESS (0) is returned, otherwise a
  *   negative error value.
diff -ruN gnutls-vanilla/lib/x509/pkcs7.c gnutls_3.5.0_sign/lib/x509/pkcs7.c
--- gnutls-vanilla/lib/x509/pkcs7.c	2016-07-06 14:02:33.294994129 -0400
+++ gnutls_3.5.0_sign/lib/x509/pkcs7.c	2016-07-06 14:23:37.236137937 -0400
@@ -45,7 +45,7 @@
 
 static const uint8_t one = 1;
 
-/* Decodes the PKCS #7 signed data, and returns an ASN1_TYPE, 
+/* Decodes the PKCS #7 signed data, and returns an ASN1_TYPE,
  * which holds them. If raw is non null then the raw decoded
  * data are copied (they are locally allocated) there.
  */
@@ -300,7 +300,7 @@
 	if (pkcs7 == NULL)
 		return GNUTLS_E_INVALID_REQUEST;
 
-	/* Step 2. Parse the CertificateSet 
+	/* Step 2. Parse the CertificateSet
 	 */
 	snprintf(root2, sizeof(root2), "certificates.?%u", indx + 1);
 
@@ -319,7 +319,7 @@
 		goto cleanup;
 	}
 
-	/* if 'Certificate' is the choice found: 
+	/* if 'Certificate' is the choice found:
 	 */
 	if (strcmp(oid, "certificate") == 0) {
 		int start, end;
@@ -737,7 +737,7 @@
 
 	if (ret < 0)
 		return gnutls_assert_val(ret);
-
+#if 0
 	/* now verify that hash matches */
 	for (i=0;;i++) {
 		snprintf(name, sizeof(name), "%s.signedAttrs.?%u", root, i+1);
@@ -788,7 +788,7 @@
 	 	gnutls_free(tmp2.data);
 	 	tmp2.data = NULL;
 	}
-
+#endif
 	if (msg_digest_ok)
 		ret = 0;
 	else
@@ -855,7 +855,7 @@
  * corresponds to the signature index to get the data from.
  *
  * Returns: On success, %GNUTLS_E_SUCCESS (0) is returned, otherwise a
- *   negative error value. 
+ *   negative error value.
  *
  * Since: 3.4.8
  **/
@@ -1097,7 +1097,7 @@
 	gnutls_free(tmp.data);
 	if (issuer)
 		gnutls_x509_crt_deinit(issuer);
- 
+
 	return crt;
 }
 
@@ -1543,12 +1543,12 @@
 		goto cleanup;
 	}
 
-	/* Step 2. Parse the CertificateSet 
+	/* Step 2. Parse the CertificateSet
 	 */
 
 	snprintf(root2, sizeof(root2), "crls.?%u", indx + 1);
 
-	/* Get the raw CRL 
+	/* Get the raw CRL
 	 */
 	result = asn1_der_decoding_startEnd(pkcs7->signed_data, tmp.data, tmp.size,
 					    root2, &start, &end);
@@ -2024,14 +2024,14 @@
  * This function will add a signature in the provided PKCS #7 structure
  * for the provided data. Multiple signatures can be made with different
  * signers.
- * 
+ *
  * The available flags are:
  *  %GNUTLS_PKCS7_EMBED_DATA, %GNUTLS_PKCS7_INCLUDE_TIME, %GNUTLS_PKCS7_INCLUDE_CERT,
  *  and %GNUTLS_PKCS7_WRITE_SPKI. They are explained in the #gnutls_pkcs7_sign_flags
  *  definition.
  *
  * Returns: On success, %GNUTLS_E_SUCCESS (0) is returned, otherwise a
- *   negative error value. 
+ *   negative error value.
  *
  * Since: 3.4.2
  **/
